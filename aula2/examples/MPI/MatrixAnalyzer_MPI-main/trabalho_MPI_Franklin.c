// Comando para gerar o executável:
// mpicc -o trabalho_MPI_Franklin trabalho_MPI_Franklin.c -lm

// explicação sobre a flag -lm:
// math.h is not a part of the standard C library, so you have to link to it! 
// link da explicação: https://stackoverflow.com/questions/44175151/what-is-the-meaning-of-lm-in-gcc

// Comando para executar
// mpirun -np 4 ./trabalho_MPI_Franklin

#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <time.h>
#include <math.h>

#define N 1000 // Define o tamanho da matriz

// Função para gerar uma matriz com valores aleatórios entre -1000 e 1000
void generate_matrix(int matrix[N][N]) {
    srand(time(NULL)); // Semente para gerar números aleatórios
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            matrix[i][j] = (rand() % 2001) - 1000; // Valores entre -1000 e 1000
        }
    }
}

int main(int argc, char *argv[]) {
    int rank, size;
    MPI_Init(&argc, &argv); // Inicializa o ambiente MPI
    MPI_Comm_rank(MPI_COMM_WORLD, &rank); // Obtém o rank do processo atual
    MPI_Comm_size(MPI_COMM_WORLD, &size); // Obtém o número total de processos

    int matrix[N][N]; // Matriz principal
    int local_matrix[N / size][N]; // Parte da matriz distribuída para cada processo
    int local_neg_count = 0, local_min = INT_MAX, local_max = INT_MIN; // Variáveis locais para contagem de negativos, valor mínimo e máximo - INT(_MAX) ou (_MIN) vienheram de limits.h e representa o maior e menor valor que uma var do tipo int pode armazenar
    long long local_sum = 0; // Soma local dos elementos da matriz (long long foi utilizado para garantir que o s valores da matriz não excedam o intervalo de valores tipo int pode armazenar)
    int local_zero_count = 0; // Contagem local de zeros

    // Rank 0 gera a matriz e a distribui
    if (rank == 0) {
        generate_matrix(matrix);
        printf("Matrix generated by rank 0\n");
    }

    MPI_Barrier(MPI_COMM_WORLD); // Sincroniza todos os processos
    printf("Rank %d reached barrier\n", rank);

    // Distribui a matriz para todos os processos
    MPI_Scatter(matrix, (N * N) / size, MPI_INT, local_matrix, (N * N) / size, MPI_INT, 0, MPI_COMM_WORLD);
    // (N * N) / size: Número de elementos a serem enviados para cada processo. 
    // local_matrix:  buffer de recepção em cada processo
    // MPI_COMM_WORLD: O comunicador que define o grupo de processos envolvidos na operação.
    printf("Rank %d completed scatter\n", rank);
    /* É uma forma de comunicação coletiva onde um processo, conhecido como o "processo raiz", 
    envia diferentes partes de um buffer para todos os outros processos.*/

    // Cada processo calcula seus valores locais
    for (int i = 0; i < N / size; i++) {
        for (int j = 0; j < N; j++) {
            int val = local_matrix[i][j];
            if (val < 0) local_neg_count++;
            if (val < local_min) local_min = val;
            if (val > local_max) local_max = val;
            local_sum += val;
            if (val == 0) local_zero_count++;
        }
    }

    int global_neg_count, global_min, global_max, global_zero_count;
    long long global_sum;
    double mean; // Media

    // Reduz os valores locais para os valores globais
    MPI_Reduce(&local_neg_count, &global_neg_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
    MPI_Reduce(&local_min, &global_min, 1, MPI_INT, MPI_MIN, 0, MPI_COMM_WORLD);
    MPI_Reduce(&local_max, &global_max, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);
    MPI_Reduce(&local_sum, &global_sum, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);
    MPI_Reduce(&local_zero_count, &global_zero_count, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
    
    // A função Reduce combina valores de todos os processos em um único valor agregado no processo raiz


    mean = (double)global_sum / (N * N); // Calcula a média dos elementos

    double local_variance_sum = 0.0; // Soma local da variância
    for (int i = 0; i < N / size; i++) {
        for (int j = 0; j < N; j++) {
            local_variance_sum += pow(local_matrix[i][j] - mean, 2); // Calcula a diferença ao quadrado da média
        }
    }

    double global_variance_sum;
    // Reduz a soma das variâncias locais para a soma global
    MPI_Reduce(&local_variance_sum, &global_variance_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);

    // Rank 0 exibe os resultados
    if (rank == 0) {
        double stddev = sqrt(global_variance_sum / (N * N)); // Calcula o desvio padrão

        printf("Contagem de elementos negativos: %d\n", global_neg_count);
        printf("Menor valor: %d\n", global_min);
        printf("Maior valor: %d\n", global_max);
        printf("Média: %.2f\n", mean);
        printf("Desvio padrão: %.2f\n", stddev);
        printf("Número de ocorrências do valor zero: %d\n", global_zero_count);
        printf("A matriz é %sesparsa.\n", (global_zero_count > (N * N) / 2) ? "" : "não ");
    }

    MPI_Finalize(); // Finaliza o ambiente MPI
    return 0;
}

